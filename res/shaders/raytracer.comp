#version 430 core

// Ray Tracer Compute Shader
// Führt GPU-basiertes Ray Tracing mit PBR-Materialien, MSAA, Reflexionen und temporaler Akkumulation durch

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform writeonly image2D outputImage;
layout(rgba32f, binding = 1) uniform image2D accumulationImage; // Für temporale Akkumulation

// Material-Struktur
struct Material {
    vec3 albedo;
    float roughness;
    vec3 emission;
    float metallic;
};

// Sphere-Struktur
struct Sphere {
    vec3 center;
    float radius;
    int materialIndex;
    float _pad0, _pad1, _pad2; // Padding für Alignment
};

// Box-Struktur (AABB)
struct Box {
    vec3 minBounds;
    float _pad0;
    vec3 maxBounds;
    int materialIndex;
};

// ============================================================================
// PHASE 3: TRIANGLE MESH AND BVH STRUCTURES
// ============================================================================

/**
 * TriangleGPU: GPU-compatible triangle structure (std430 layout)
 * ---------------------------------------------------------------
 * Memory Layout (must match C++ GPUStructs::TriangleGPU):
 * - v0: vec3 @ offset 0  (16-byte aligned due to std430)
 * - v1: vec3 @ offset 16
 * - v2: vec3 @ offset 32
 * - normal: vec3 @ offset 48
 * - materialIndex: int @ offset 64
 * Total size: 80 bytes
 * 
 * NOTE: GLSL automatically pads vec3 to 16 bytes in buffer layouts!
 */
struct TriangleGPU {
    vec3 v0;              // Vertex 0
    vec3 v1;              // Vertex 1
    vec3 v2;              // Vertex 2
    vec3 normal;          // Pre-computed surface normal
    int materialIndex;    // Material index
};

/**
 * BVHNodeGPU: GPU-compatible BVH node structure (std430 layout)
 * --------------------------------------------------------------
 * Memory Layout (must match C++ GPUStructs::BVHNodeGPU):
 * - aabbMin: vec3 @ offset 0
 * - aabbMax: vec3 @ offset 16
 * - leftChild: int @ offset 32
 * - rightChild: int @ offset 36
 * - triangleIndex: int @ offset 40
 * - triangleCount: int @ offset 44
 * Total size: 48 bytes
 * 
 * BVH Traversal Logic:
 * - Internal Node: triangleCount == 0, leftChild >= 0, rightChild >= 0
 * - Leaf Node: triangleCount > 0, contains triangles[triangleIndex..triangleIndex+count-1]
 */
struct BVHNodeGPU {
    vec3 aabbMin;         // AABB minimum bounds
    vec3 aabbMax;         // AABB maximum bounds
    int leftChild;        // Index to left child (-1 if leaf)
    int rightChild;       // Index to right child (-1 if leaf)
    int triangleIndex;    // First triangle index (if leaf)
    int triangleCount;    // Number of triangles (0 if internal node)
};

// Hit-Record (extended for barycentric coordinates)
struct HitRecord {
    float t;
    vec3 point;
    vec3 normal;
    bool frontFace;
    int materialIndex;
    vec2 barycentricCoords; // u, v for texture mapping (Phase 4)
};

// Shader Storage Buffer Objects (SSBOs)
layout(std430, binding = 1) buffer SphereBuffer {
    Sphere spheres[];
};

layout(std430, binding = 2) buffer BoxBuffer {
    Box boxes[];
};

layout(std430, binding = 3) buffer MaterialBuffer {
    Material materials[];
};

// Triangle Mesh and BVH Buffers (Phase 3)
layout(std430, binding = 4) buffer TriangleBuffer {
    TriangleGPU triangles[];
};

layout(std430, binding = 5) buffer BVHBuffer {
    BVHNodeGPU bvhNodes[];
};

// Uniforms
uniform int numSpheres;
uniform int numBoxes;
uniform int numTriangles;  // Phase 3: Number of triangles
uniform int numBVHNodes;   // Phase 3: Number of BVH nodes
uniform int samplesPerPixel;
uniform int maxBounces;
uniform vec3 cameraPos;
uniform vec3 cameraTarget;
uniform vec3 cameraUp;
uniform float cameraVFov;
uniform float cameraAspect;
// Kein Richtungslicht mehr - nur emissive Deckenlampe
uniform uint frameCount; // Für unterschiedliche Random Seeds pro Frame
uniform uint accumulatedFrames; // Anzahl akkumulierter Frames für progressive Rendering

// Kamera-Basis-Vektoren (werden in CPU berechnet und übergeben)
uniform vec3 cameraU;
uniform vec3 cameraV;
uniform vec3 cameraW;
uniform vec3 cameraLowerLeft;
uniform vec3 cameraHorizontal;
uniform vec3 cameraVertical;

// ===== RANDOM NUMBER GENERATION =====
// PCG Hash für Pseudo-Zufallszahlen
uint pcg_hash(uint seed) {
    uint state = seed * 747796405u + 2891336453u;
    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;
    return (word >> 22u) ^ word;
}

// Random [0,1]
float random01(inout uint seed) {
    seed = pcg_hash(seed);
    return float(seed) / 4294967296.0;
}

// Random in Hemisphere um Normal
vec3 randomInHemisphere(vec3 normal, inout uint seed) {
    float z = random01(seed) * 2.0 - 1.0;
    float a = random01(seed) * 2.0 * 3.14159265;
    float r = sqrt(1.0 - z * z);
    vec3 dir = vec3(r * cos(a), r * sin(a), z);
    
    if (dot(dir, normal) < 0.0) {
        dir = -dir;
    }
    return normalize(dir);
}

// ===== RAY INTERSECTION TESTS =====

// Ray-Sphere Intersection
bool hitSphere(vec3 rayOrigin, vec3 rayDir, Sphere sphere, float tMin, float tMax, inout HitRecord rec) {
    vec3 oc = rayOrigin - sphere.center;
    float a = dot(rayDir, rayDir);
    float half_b = dot(oc, rayDir);
    float c = dot(oc, oc) - sphere.radius * sphere.radius;
    float discriminant = half_b * half_b - a * c;
    
    if (discriminant < 0.0) return false;
    
    float sqrtD = sqrt(discriminant);
    float root = (-half_b - sqrtD) / a;
    
    if (root < tMin || root > tMax) {
        root = (-half_b + sqrtD) / a;
        if (root < tMin || root > tMax) return false;
    }
    
    rec.t = root;
    rec.point = rayOrigin + rec.t * rayDir;
    vec3 outwardNormal = (rec.point - sphere.center) / sphere.radius;
    rec.frontFace = dot(rayDir, outwardNormal) < 0.0;
    rec.normal = rec.frontFace ? outwardNormal : -outwardNormal;
    rec.materialIndex = sphere.materialIndex;
    
    return true;
}

// Ray-Box Intersection (AABB Slab Method)
bool hitBox(vec3 rayOrigin, vec3 rayDir, Box box, float tMin, float tMax, inout HitRecord rec) {
    float t0 = tMin;
    float t1 = tMax;
    
    // Teste jede Achse
    for (int axis = 0; axis < 3; ++axis) {
        float invD = 1.0 / rayDir[axis];
        float tNear = (box.minBounds[axis] - rayOrigin[axis]) * invD;
        float tFar = (box.maxBounds[axis] - rayOrigin[axis]) * invD;
        
        if (tNear > tFar) {
            float temp = tNear;
            tNear = tFar;
            tFar = temp;
        }
        
        t0 = max(tNear, t0);
        t1 = min(tFar, t1);
        
        if (t0 > t1) return false;
    }
    
    rec.t = t0;
    rec.point = rayOrigin + rec.t * rayDir;
    
    // Berechne Normal
    vec3 center = (box.minBounds + box.maxBounds) * 0.5;
    vec3 localHit = rec.point - center;
    vec3 halfSize = (box.maxBounds - box.minBounds) * 0.5;
    
    vec3 normal = vec3(0.0);
    float maxComponent = 0.0;
    for (int i = 0; i < 3; ++i) {
        float component = abs(localHit[i] / halfSize[i]);
        if (component > maxComponent) {
            maxComponent = component;
            normal = vec3(0.0);
            normal[i] = localHit[i] > 0.0 ? 1.0 : -1.0;
        }
    }
    
    rec.frontFace = dot(rayDir, normal) < 0.0;
    rec.normal = rec.frontFace ? normal : -normal;
    rec.materialIndex = box.materialIndex;
    
    return true;
}

// ============================================================================
// PHASE 3: TRIANGLE-RAY INTERSECTION (MÖLLER-TRUMBORE ALGORITHM)
// ============================================================================

/**
 * hitTriangle - Ray-Triangle Intersection using Möller-Trumbore Algorithm
 * ------------------------------------------------------------------------
 * Fast, numerically stable algorithm for ray-triangle intersection.
 * Returns barycentric coordinates (u, v) for texture mapping.
 * 
 * Algorithm Reference:
 * - "Fast, Minimum Storage Ray-Triangle Intersection" (Möller & Trumbore, 1997)
 * - Computes intersection in barycentric space
 * - Single-sided by default (culls back faces)
 * 
 * @param rayOrigin - Ray origin point
 * @param rayDir - Ray direction (normalized)
 * @param tri - Triangle to test
 * @param tMin - Minimum ray parameter
 * @param tMax - Maximum ray parameter
 * @param rec - Output hit record
 * @return true if hit, false otherwise
 * 
 * Performance: ~10-15 instructions, highly optimized for GPU
 */
bool hitTriangle(vec3 rayOrigin, vec3 rayDir, TriangleGPU tri, 
                 float tMin, float tMax, inout HitRecord rec) {
    const float EPSILON = 0.0000001;
    
    // Edge vectors
    vec3 edge1 = tri.v1 - tri.v0;
    vec3 edge2 = tri.v2 - tri.v0;
    
    // Begin Möller-Trumbore algorithm
    vec3 h = cross(rayDir, edge2);
    float a = dot(edge1, h);
    
    // Ray parallel to triangle plane - no intersection
    if (abs(a) < EPSILON) {
        return false;
    }
    
    float f = 1.0 / a;
    vec3 s = rayOrigin - tri.v0;
    float u = f * dot(s, h);
    
    // Barycentric coordinate u out of range [0,1]
    if (u < 0.0 || u > 1.0) {
        return false;
    }
    
    vec3 q = cross(s, edge1);
    float v = f * dot(rayDir, q);
    
    // Barycentric coordinate v out of range, or u+v > 1
    if (v < 0.0 || u + v > 1.0) {
        return false;
    }
    
    // Compute t to find intersection point
    float t = f * dot(edge2, q);
    
    // Check if intersection is within ray bounds
    if (t < tMin || t > tMax) {
        return false;
    }
    
    // Valid intersection - fill hit record
    rec.t = t;
    rec.point = rayOrigin + t * rayDir;
    
    // Use pre-computed normal from triangle
    vec3 outwardNormal = tri.normal;
    
    // Determine front face vs back face
    rec.frontFace = dot(rayDir, outwardNormal) < 0.0;
    rec.normal = rec.frontFace ? outwardNormal : -outwardNormal;
    
    rec.materialIndex = tri.materialIndex;
    rec.barycentricCoords = vec2(u, v);
    
    return true;
}

// ============================================================================
// PHASE 3: BVH TRAVERSAL
// ============================================================================

/**
 * intersectAABB - Ray-AABB Intersection Test
 * --------------------------------------------
 * Optimized slab method for ray-box intersection.
 * Used for BVH traversal to skip empty space.
 * 
 * @param rayOrigin - Ray origin
 * @param rayDir - Ray direction (normalized)
 * @param rayInvDir - Precomputed 1.0/rayDir (for optimization)
 * @param aabbMin - AABB minimum corner
 * @param aabbMax - AABB maximum corner
 * @param tMin - Minimum ray parameter
 * @param tMax - Maximum ray parameter
 * @return true if ray intersects AABB
 * 
 * Performance: ~6-8 instructions, highly parallel
 */
bool intersectAABB(vec3 rayOrigin, vec3 rayDir, vec3 rayInvDir,
                   vec3 aabbMin, vec3 aabbMax, float tMin, float tMax) {
    // Slab method: compute intersection for each axis
    vec3 t0 = (aabbMin - rayOrigin) * rayInvDir;
    vec3 t1 = (aabbMax - rayOrigin) * rayInvDir;
    
    // Ensure t0 <= t1 for each axis
    vec3 tNear = min(t0, t1);
    vec3 tFar = max(t0, t1);
    
    // Find the largest tNear and smallest tFar
    float tNearMax = max(max(tNear.x, tNear.y), tNear.z);
    float tFarMin = min(min(tFar.x, tFar.y), tFar.z);
    
    // Check if there's an intersection
    return tNearMax <= tFarMin && tFarMin >= tMin && tNearMax <= tMax;
}

/**
 * hitBVH - BVH Traversal for Triangle Mesh
 * ------------------------------------------
 * Iterative, stack-based BVH traversal algorithm.
 * Finds closest intersection with triangle mesh.
 * 
 * Architecture:
 * - Stack-based traversal (no recursion on GPU)
 * - Depth-first search pattern
 * - Early exit on closest hit
 * - AABB culling for empty space skipping
 * 
 * @param rayOrigin - Ray origin
 * @param rayDir - Ray direction (normalized)
 * @param tMin - Minimum ray parameter
 * @param tMax - Maximum ray parameter
 * @param rec - Output hit record
 * @return true if any triangle was hit
 * 
 * Performance Notes:
 * - Stack size: 64 entries (sufficient for depth ~20 BVH)
 * - Average traversal: 10-30 node tests for typical scenes
 * - Worst case: O(log n) for balanced BVH
 */
bool hitBVH(vec3 rayOrigin, vec3 rayDir, float tMin, float tMax, inout HitRecord rec) {
    // Early exit if no BVH nodes
    if (numBVHNodes <= 0) {
        return false;
    }
    
    // Precompute inverse ray direction for AABB tests
    vec3 rayInvDir = vec3(1.0) / rayDir;
    
    // Stack for iterative traversal (64 entries = depth ~20)
    const int MAX_STACK_SIZE = 64;
    int stack[MAX_STACK_SIZE];
    int stackPtr = 0;
    
    // Push root node (index 0)
    stack[stackPtr++] = 0;
    
    bool hitAnything = false;
    float closest = tMax;
    HitRecord tempRec;
    
    // Iterative traversal
    while (stackPtr > 0) {
        // Pop node from stack
        int nodeIdx = stack[--stackPtr];
        
        // Bounds check
        if (nodeIdx < 0 || nodeIdx >= numBVHNodes) {
            continue;
        }
        
        BVHNodeGPU node = bvhNodes[nodeIdx];
        
        // Test ray against node's AABB
        if (!intersectAABB(rayOrigin, rayDir, rayInvDir, 
                          node.aabbMin, node.aabbMax, tMin, closest)) {
            continue; // Skip this node and its children
        }
        
        // Check if this is a leaf node
        if (node.triangleCount > 0) {
            // Leaf node - test all triangles
            for (int i = 0; i < node.triangleCount; ++i) {
                int triIdx = node.triangleIndex + i;
                
                // Bounds check for triangle array
                if (triIdx < 0 || triIdx >= numTriangles) {
                    continue;
                }
                
                if (hitTriangle(rayOrigin, rayDir, triangles[triIdx], 
                               tMin, closest, tempRec)) {
                    hitAnything = true;
                    closest = tempRec.t;
                    rec = tempRec;
                }
            }
        } else {
            // Internal node - push children to stack
            // Push right child first so left is processed first (depth-first)
            if (node.rightChild >= 0 && stackPtr < MAX_STACK_SIZE) {
                stack[stackPtr++] = node.rightChild;
            }
            if (node.leftChild >= 0 && stackPtr < MAX_STACK_SIZE) {
                stack[stackPtr++] = node.leftChild;
            }
        }
    }
    
    return hitAnything;
}

// Teste alle Objekte (Spheres, Boxes, and Triangles via BVH)
bool hitWorld(vec3 rayOrigin, vec3 rayDir, float tMin, float tMax, inout HitRecord rec) {
    bool hitAnything = false;
    float closest = tMax;
    HitRecord tempRec;
    
    // Teste Spheres
    for (int i = 0; i < numSpheres; ++i) {
        if (hitSphere(rayOrigin, rayDir, spheres[i], tMin, closest, tempRec)) {
            hitAnything = true;
            closest = tempRec.t;
            rec = tempRec;
        }
    }
    
    // Teste Boxes
    for (int i = 0; i < numBoxes; ++i) {
        if (hitBox(rayOrigin, rayDir, boxes[i], tMin, closest, tempRec)) {
            hitAnything = true;
            closest = tempRec.t;
            rec = tempRec;
        }
    }
    
    // Phase 3: Test Triangle Mesh via BVH
    // BVH provides O(log n) acceleration for large triangle meshes
    if (hitBVH(rayOrigin, rayDir, tMin, closest, tempRec)) {
        hitAnything = true;
        closest = tempRec.t;
        rec = tempRec;
    }
    
    return hitAnything;
}

// Hintergrundfarbe
vec3 background(vec3 rayDir) {
    return vec3(0.1, 0.1, 0.1); // Gleiche Farbe wie CPU-Version
}

// Reflexion
vec3 reflect_vec(vec3 incident, vec3 normal) {
    return incident - 2.0 * dot(incident, normal) * normal;
}

// Ray Tracing Shading mit Reflexionen
vec3 shade(vec3 rayOrigin, vec3 rayDir, inout uint seed) {
    vec3 color = vec3(0.0);
    vec3 throughput = vec3(1.0); // Wie viel Licht noch "durchgelassen" wird
    
    for (int bounce = 0; bounce < maxBounces; ++bounce) {
        HitRecord rec;
        
        if (!hitWorld(rayOrigin, rayDir, 0.001, 1e30, rec)) {
            // Kein Treffer - füge Hintergrund hinzu
            color += throughput * background(rayDir);
            break;
        }
        
        Material mat = materials[rec.materialIndex];
        
        // Emission - Lichtquellen leuchten direkt
        color += throughput * mat.emission;
        
        // Sehr reduziertes Ambient nur um komplette Dunkelheit zu vermeiden
        // Hauptbeleuchtung kommt von der Deckenlampe durch Bounces
        vec3 ambient = mat.albedo * 0.02; // Stark reduziert für echte Schatten
        
        // Berechne neue Strahlrichtung
        vec3 perfectReflection = reflect_vec(rayDir, rec.normal);
        vec3 diffuseReflection = randomInHemisphere(rec.normal, seed);
        
        // Interpoliere basierend auf Roughness
        vec3 reflectionDir = normalize(mix(perfectReflection, diffuseReflection, mat.roughness));
        
        // Aktualisiere Farbe mit minimalem Ambient
        color += throughput * ambient;
        
        // Aktualisiere Throughput für nächsten Bounce
        // Diffuse Oberflächen absorbieren Licht basierend auf Albedo
        // Metallische Oberflächen reflektieren mit ihrer Farbe
        vec3 surfaceColor = mix(mat.albedo, mat.albedo, mat.roughness); // Diffuse Oberflächen nutzen Albedo
        throughput *= surfaceColor;
        
        // Russisches Roulette für frühe Terminierung
        // Start nach 3 Bounces um initiale Reflexionen sicherzustellen
        const int RR_START_BOUNCE = 3;
        if (bounce > RR_START_BOUNCE) {
            float p = max(throughput.r, max(throughput.g, throughput.b));
            if (random01(seed) > p) break;
            throughput /= p;
        }
        
        // Setup für nächsten Bounce
        rayOrigin = rec.point;
        rayDir = reflectionDir;
    }
    
    return color;
}

void main() {
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 imageDims = imageSize(outputImage);
    
    // Prüfe Bounds
    if (pixelCoords.x >= imageDims.x || pixelCoords.y >= imageDims.y) {
        return;
    }
    
    // Initialisiere Random Seed basierend auf Pixel-Position und Frame
    uint seed = pixelCoords.x + pixelCoords.y * imageDims.x + frameCount * imageDims.x * imageDims.y;
    seed = pcg_hash(seed);
    
    vec3 pixelColor = vec3(0.0);
    
    // Multi-Sample Anti-Aliasing
    for (int s = 0; s < samplesPerPixel; ++s) {
        // Zufälliges Sub-Pixel Offset
        float offsetX = samplesPerPixel > 1 ? random01(seed) : 0.5;
        float offsetY = samplesPerPixel > 1 ? random01(seed) : 0.5;
        
        float u = (float(pixelCoords.x) + offsetX) / float(imageDims.x - 1);
        float v = (float(pixelCoords.y) + offsetY) / float(imageDims.y - 1);
        
        // Erzeuge Strahl
        vec3 rayOrigin = cameraPos;
        vec3 rayDir = normalize(cameraLowerLeft + u * cameraHorizontal + v * cameraVertical - cameraPos);
        
        // Trace Ray
        pixelColor += shade(rayOrigin, rayDir, seed);
    }
    
    // Mittelwertbildung über Samples
    pixelColor /= float(samplesPerPixel);
    
    // ===== TEMPORALE AKKUMULATION =====
    // Mische aktuelles Frame mit akkumulierten vorherigen Frames
    if (accumulatedFrames > 0) {
        // Lade vorheriges akkumuliertes Ergebnis
        vec4 previousColor = imageLoad(accumulationImage, pixelCoords);
        
        // Berechne gewichteten Durchschnitt
        // Je mehr Frames akkumuliert wurden, desto weniger Gewicht hat das neue Frame
        float weight = 1.0 / float(accumulatedFrames + 1);
        pixelColor = mix(previousColor.rgb, pixelColor, weight);
    }
    
    // Speichere akkumuliertes Ergebnis
    imageStore(accumulationImage, pixelCoords, vec4(pixelColor, 1.0));
    
    // Schreibe finales Bild in Output-Image
    imageStore(outputImage, pixelCoords, vec4(pixelColor, 1.0));
}
